#!/usr/bin/env python

"""
Roam settings for ST2, ST3, shell settings etc.
"""

import os
import platform
import shutil
import sys

P_LINUX = 'linux'
P_OSX = 'darwin'
P_WINDOWS = 'windows'

PLATFORM_SYSTEM = platform.system().lower()
if PLATFORM_SYSTEM == P_WINDOWS:
  HOME = os.environ.get('APPDATA')
else:
  HOME = os.environ.get('HOME')
if not HOME:
  HOME = os.path.expanduser('~')
ROAMING_ROOT = os.path.dirname(os.path.abspath(os.path.expanduser(__file__)))

if PLATFORM_SYSTEM == P_WINDOWS:
  # Add support for os.symlink and os.path.islink on Windows...

  import ctypes
  from ctypes import windll
  __CSL = None
  FILE_ATTRIBUTE_REPARSE_POINT = 0x0400
  GetFileAttributes = windll.kernel32.GetFileAttributesW

  def symlink(source, link_name):
    global __CSL
    if __CSL is None:
      csl = ctypes.windll.kernel32.CreateSymbolicLinkW
      csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)
      csl.restype = ctypes.c_ubyte
      __CSL = csl
    flags = 0
    if source is not None and os.path.isdir(source):
      flags = 1
    if __CSL(link_name, source, flags) == 0:
      raise ctypes.WinError()

  def islink(path):
    res = GetFileAttributes(path)
    if res & FILE_ATTRIBUTE_REPARSE_POINT:
      return True
    else:
      return False

  os.symlink = symlink
  os.path.islink = islink


def _roaming_path(*components):
  """ Path in roaming folder for 'components' (relative) """
  return os.path.join(ROAMING_ROOT, *components)

def _short_path(path):
  """ Shortened 'path' if possible (replace expanded HOME with ~) """
  return path.replace(HOME, '~')

def _get_description_from_file(fpath):
  """ Return comment found on first line in 'fpath', if available """
  res = ''
  try:
    with open(fpath) as fh:
      line = fh.readline().strip()
      if line.startswith('#'):
        res = line[1:].strip()
  except Exception:
    pass
  if not res and fpath.endswith('default.cfg'):
    res = "Default settings (applied when script ran without any arguments)"
  return res

def _delete(report, path, commit):
  """ Delete file/folder with 'path' """
  if report.errors:
    return report
  if not os.path.exists(path) and not os.path.islink(path):
    return report
  if commit:
    report.log("Deleting %s", path)
    if os.path.isfile(path) or os.path.islink(path):
      os.unlink(path)
    else:
      shutil.rmtree(path)
  else:
    report.log("Will delete %s", path)
  return report

def _symlink(report, local, roaming, commit):
  """ Create symlink local -> roaming """
  if report.errors:
    return report
  if not os.path.exists(roaming) and commit:
    return report.error("%s does not exist", roaming)
  if commit:
    report.log("Creating symlink %s -> %s", local, roaming)
    os.symlink(roaming, local)
  else:
    report.log("Will create symlink %s -> %s", local, roaming)
  return report

def _copy(report, source, dest, commit):
  """ Copy file/folder 'source' -> 'dest' """
  if report.errors:
    return report
  if not os.path.exists(source):
    return report.error("%s does not exist", source)
  if commit:
    report.log("Copying %s -> %s", source, dest)
    parent = os.path.dirname(dest)
    if not os.path.isdir(parent):
      os.makedirs(parent)
    if os.path.isdir(source):
      shutil.copytree(source, dest, symlinks=False)
    else:
      shutil.copy(source, dest)
  else:
    report.log("Will copy %s -> %s", source, dest)
  return report


class Report(object):
  """ Simple reporting """

  def __init__(self, title=''):
    self.title = title
    self.messages = []
    self.logs = 0
    self.errors = 0

  def _log(self, msg, *args):
    if args:
      msg = msg % args
    if self.title:
      msg = self.title + ': ' + msg
    self.messages.append(_short_path(msg))
    return self

  def info(self, msg, *args):
    return self._log(msg, *args)

  def log(self, msg, *args):
    self.logs += 1
    return self._log(msg, *args)

  def error(self, msg, *args):
    self.errors += 1
    return self._log(msg, *args)

  def add(self, other):
    assert other
    self.logs += other.logs
    self.errors += other.errors
    for m in other.messages:
      self.messages.append(m)

  def __str__(self):
    return '\n'.join(self.messages)


class Spec(object):
  """ File or folder roaming spec """

  def __init__(self, section, name, local_path, doc):
    #: Parent section, defines which roaming subfolder this should go under
    self.section = section
    #: Name of the file or folder roamed
    self.name = name
    #: Full path to local file (outside of roaming folder)
    self.local_path = os.path.expanduser(local_path)
    # Full path to roaming file (inside roaming folder)
    self.roaming_path = _roaming_path(self.section.folder, self.name)
    #: Short explanation of what the file/folder is
    self.doc = doc

  def __repr__(self):
    return '%s -> %s' % (_short_path(self.local_path), _short_path(_roaming_path(self.section.folder, self.name)))

  def setup(self, commit):
    """
      Link 'self.local_path' to roaming correspondent,
      if roaming correspondent does not exist, create it from the contents of 'self.local_path',
      then delete self.local_path and link it to roaming
      @param bool commit: Commit changes when true
      @return Report: Report on how setup went, what was done or would be done if 'commit' was True
    """
    report = Report(self.section.folder)
    if os.path.islink(self.local_path):
      if os.path.realpath(self.local_path) == self.roaming_path or PLATFORM_SYSTEM == P_WINDOWS:
        # FIXME: Need a good implementation for os.path.realpath on Windows
        return report.info("OK %s -> %s", self.local_path, self.roaming_path)
    if not os.path.exists(self.roaming_path):
      # Initialize self.roaming_path from self.local_path
      _copy(report, self.local_path, self.roaming_path, commit)
    _delete(report, self.local_path, commit)
    _symlink(report, self.local_path, self.roaming_path, commit)
    return report

  def help(self):
    return '%-20s %s' % (self.name, self.doc)


class Section(object):
  """ Roaming section """

  def __init__(self, folder):
    """
      @param str folder: Sub folder to use for this section in ROAMING_ROOT
    """
    #: Supported platforms
    self.platforms = [P_LINUX, P_OSX, P_WINDOWS]
    #: Folder name holding the roamed settings
    self.folder = folder
    #: Specifications to roam for this section
    self.specs = []

  def __repr__(self):
    return '%s [%s] %s specs' % (self.folder, ' '.join(self.platforms), len(self.specs))

  def has_roamable(self, name):
    """
      @param str name: Name of roamable
      @return bool: Do we have a roamable with 'name'?
    """
    if self.folder.lower() == name.lower():
      return True
    for spec in self.specs:
      if name.lower() == spec.name.lower():
        return True
    return False

  def add_spec(self, name, local_path, doc):
    """
      @param str name: Name of the file or folder roamed
      @param str local_path: Full path to local file (outside of roaming folder)
      @param str doc: Short Short explanation of what the file/folder is
    """
    spec = Spec(self, name, local_path, doc)
    self.specs.append(spec)

  def add_simple_file_spec(self, name, doc, local_path=None):
    """
      @param str name: Name of the file or folder roamed
      @param str doc: Short Short explanation of what the file/folder is
      @param str local_path: Full path to local file (outside of roaming folder), default ~/.<name>
    """
    if not local_path:
      local_path = os.path.join(HOME, '.' + name)
      doc = '%s (%s)' % (doc, _short_path(local_path))
    local_path = os.path.expanduser(local_path)
    self.add_spec(name, local_path, doc)

  def setup(self, settings, commit):
    """
      @param Settings settings: What the user wants roamed
      @param bool commit: Commit changes when true
      @return Report: Report on how setup went, what was done or would be done if 'commit' was True
    """
    rep = Report(self.folder)
    do_entire_section = self.folder.lower() in settings.active
    platform_supported = PLATFORM_SYSTEM in self.platforms
    match_count = 0
    for spec in self.specs:
      if not do_entire_section and not settings.is_active(spec.name):
        continue
      match_count += 1
      if platform_supported:
        rep.add(spec.setup(commit))
    if match_count and not platform_supported:
      return rep.info("Skipped on this platform, only available on %s", ' '.join(self.platforms))
    return rep

  def help(self, platform):
    res = ''
    if platform and platform not in self.platforms:
      return res
    res += '%s (%s)\n' % (self.folder, self.__doc__.strip())
    for spec in self.specs:
      res += '  %s\n' % spec.help()
    return res


class ShellSection(Section):
  """ Shell specific settings """

  def __init__(self):
    super(ShellSection, self).__init__('shell')
    self.platforms = [P_LINUX, P_OSX]
    self.add_simple_file_spec('zshrc', "zsh settings")
    self.add_simple_file_spec('oh-my-zsh', "oh-my-zsh checkout")
    self.add_simple_file_spec('bashrc', "bash session settings")
    self.add_simple_file_spec('bashrc_profile', "bash login settings")
    self.add_simple_file_spec('profile', "Shell login settings")
    self.add_simple_file_spec('inputrc', "Readline library configuration")
    self.add_simple_file_spec('vimrc', "VIm configuration")
    self.add_simple_file_spec('tmux.conf', "tmux configuration")
    self.add_simple_file_spec('screenrc', "screen configuration")


class SshSection(Section):
  """ ssh settings """

  def __init__(self):
    super(SshSection, self).__init__('ssh')
    self.platforms = [P_LINUX, P_OSX]
    self.add_ssh_file('config', "ssh configuration (~/.ssh/config)")

  def add_ssh_file(self, name, doc):
    self.add_spec(name, os.path.join(HOME, '.ssh', name), doc)


class OSXSection(Section):
  """ OSX specific settings """

  def __init__(self):
    super(OSXSection, self).__init__('osx')
    self.platforms = [P_OSX]
    self.add_spec('KeyBindings', '~/Library/KeyBindings', 'Cocoa key bindings (~/Library/KeyBindings)')
    self.add_spec('iTerm/com.googlecode.iterm2.plist', '~/Library/Preferences/com.googlecode.iterm2.plist', 'iTerm2 settings')


class SublimeSection(Section):
  """ Sublime Text section (common implementation) """

  def __init__(self, version):
    self.version = version
    self.short_name = 'ST%s' % self.version
    self.long_name = 'Sublime Text %s' % self.version
    self.local_path = None
    if PLATFORM_SYSTEM == P_LINUX:
      self.local_path = os.path.join(HOME, '.config', 'sublime-text-%s' % self.version)
    elif PLATFORM_SYSTEM == P_OSX:
      self.local_path = os.path.join(HOME, 'Library', 'Application Support', self.long_name)
    elif PLATFORM_SYSTEM == P_WINDOWS:
      self.local_path = os.path.join(HOME, self.long_name)
    super(SublimeSection, self).__init__(self.short_name)

  def setup(self, settings, commit):
    """
      @param Settings settings: What the user wants roamed
      @param bool commit: Commit changes when true
      @return Report: Report on how setup went, what was done or would be done if 'commit' was True
    """
    rep = Report(self.short_name)
    if not settings.is_active(self.short_name):
      return rep
    if not self.local_path:
      return rep.error("Can't determine where %s settings live on this platform" % self.short_name)
    if not os.path.isdir(self.local_path):
      rep.error("%s not found in %s", self.short_name, self.local_path)
      return rep.error("Please install %s and run it at least once, then try this script again", self.short_name)
    for spec in self.specs:
      rep.add(spec.setup(commit))
    return rep

  def add_settings_folder(self, name):
    self.add_spec(name, os.path.join(self.local_path, name), _short_path(os.path.join(self.local_path, name)))


class Sublime2Section(SublimeSection):
  """ Sublime Text 2 settings """

  def __init__(self):
    super(Sublime2Section, self).__init__('2')
    self.add_settings_folder('Installed Packages')
    self.add_settings_folder('Packages')
    self.add_settings_folder('Pristine Packages')


class Sublime3Section(SublimeSection):
  """ Sublime Text 3 settings """

  def __init__(self):
    super(Sublime3Section, self).__init__('3')
    self.add_settings_folder('Installed Packages')
    self.add_settings_folder('Packages')


class RoamingRunner(object):

  def __init__(self):
    self.sections = []
    self.sections.append(ShellSection())
    self.sections.append(Sublime2Section())
    self.sections.append(Sublime3Section())
    self.sections.append(SshSection())
    self.sections.append(OSXSection())

  def __repr__(self):
    return '%s sections' % len(self.sections)

  def all_settings(self):
    """
    @return Settings: Settings to roam everything we have
    """
    settings = Settings('all')
    for section in self.sections:
      settings.add_active(section.folder)
    return settings

  def setup(self, settings, commit):
    """
      @param Settings settings: Settings specifying what to roam
      @param bool commit: Commit changes when true
      @return Report: Report on how setup went, what was done or would be done if 'commit' was True
    """
    report = Report()
    for section in self.sections:
      report.add(section.setup(settings, commit))
    return report

  def available_bundles(self):
    res = ''
    for fname in os.listdir(ROAMING_ROOT):
      if fname.lower().endswith('.cfg'):
        res += '  %-20s %s\n' % (fname[:-4], _get_description_from_file(_roaming_path(fname)))
    if res:
      res = 'Available .cfg bundles:\n%s' % res
    return res

  def help(self, platform=None):
    """ List of roamable things for platform (if specified) """
    res = ''
    for section in self.sections:
      sh = section.help(platform)
      if sh:
        res += sh + '\n'
    res += self.available_bundles()
    return res

  def has_roamable(self, name):
    """
      @param str name: Name of roamable
      @return bool: Do we have a roamable with 'name'?
    """
    for section in self.sections:
      if section.has_roamable(name):
        return True

  def _add_to_settings(self, settings, what):
    """
      @param Settings settings: Settings to add to
      @param str what: What to add to 'settings'
    """
    if self.has_roamable(what):
      settings.add_active(what)
      return
    if what == 'all':
      s = self.all_settings()
    else:
      s = self.settings_from_file(what)
    if s:
      for a in s.active:
        settings.add_active(a)
    else:
      _abort("Nothing corresponds to '%s' and no file '%s.cfg' found, typo?", what, what)

  def settings_from_file(self, name):
    """
    @param str name: File name containing the settings
    @return Settings: Settings defined in file, if any
    """
    if not name:
      return None
    fpath = _roaming_path(name + '.cfg')
    if not os.path.exists(fpath):
      return None
    try:
      settings = Settings(name)
      with open(fpath) as fh:
        in_roam_section = False
        for line in fh.readlines():
          line = line.strip()
          if not line or line.startswith('#'):
            continue
          if line.startswith('['):
            in_roam_section = line == '[roam]'
            continue
          if not in_roam_section:
            continue
          self._add_to_settings(settings, line)
      return settings
    except Exception as e:
      print "Can't read file %s: %s" % (fpath, e)

    return None


class Settings(object):
  """ Settings specifying what to roam """

  def __init__(self, name):
    #: Name of setting file, if we got this object from
    self.name = name
    #: Active settings, to be roamed
    self.active = []

  def __repr__(self):
    return '(%s) %s' % (self.name, ' '.join(self.active))

  def is_active(self, name):
    return name.lower() in self.active

  def add_active(self, name):
    if isinstance(name, list):
      for s in name:
        self.add_active(s)
    else:
      self.active.append(name.lower())


def _abort(message, *args):
  if args:
    message = message % args
  print message
  print "See --help and/or --list for instructions"
  sys.exit(1)

def main():

  runner = RoamingRunner()
  args = None

  try:
    import argparse
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-l', '--list', action='store_true', help="List what can be specified as what to roam.")
    parser.add_argument('-c', '--commit', action='store_true', help="Commit changes.")
    parser.add_argument('what', nargs='*', help="What to roam (see --list for what's available).")
    args = parser.parse_args()

  except ImportError:
    # Unfortunately, python 2.6 doesn't come with argparse
    import optparse
    parser = optparse.OptionParser()
    parser.add_option('-l', '--list', action='store_true', help="List what can be specified as what to roam.")
    parser.add_option('-c', '--commit', action='store_true', help="Commit changes.")
    (args, positionals) = parser.parse_args()
    args.what = positionals

  if args.list:
    print runner.help()
    sys.exit(0)

  if args.what:
    settings = Settings('command line')
    for what in args.what:
      runner._add_to_settings(settings, what)
    if not settings.active:
      _abort("Couldn't figure out what to roam with '%s'", ' '.join(args.what))

  else:
    settings = runner.settings_from_file('default')

  if settings:
    report = runner.setup(settings, args.commit)

  else:
    print "Specify which settings to roam (see --help)"
    print "You can also create a 'default.cfg' file in the roaming folder (%s)" % ROAMING_ROOT
    print "See 'bash.cfg' for an example of how to write a 'default.cfg' file"
    sys.exit(1)

  if not report.messages:
    _abort("Couldn't figure out what to roam with '%s'", ' '.join(args.what))

  else:
    print report

    if not args.commit and report.logs and not report.errors:
      print "Use -c to effectively perform these changes"

    elif not report.logs and not report.errors:
      print "All good"

if __name__ == "__main__":
  if not HOME:
    _abort("Could not determine HOME folder, please check this script")

  main()
