#!/usr/bin/env python

"""
Roam settings for ST2, ST3, shell settings etc.
"""

import argparse
import os
import platform
import shutil
import sys

from windows import APPDATA, P_CYGWIN, P_WINDOWS

P_LINUX = 'linux'
P_OSX = 'darwin'

PLATFORM_SYSTEM = platform.system().lower()

if PLATFORM_SYSTEM.lower().startswith('cygwin'):
    PLATFORM_SYSTEM = P_CYGWIN

HOME = os.environ.get('HOME') or APPDATA

if not HOME:
    sys.exit("Could not determine HOME folder, please check")

ROAMING_ROOT = os.path.dirname(os.path.abspath(os.path.realpath(os.path.expanduser(__file__))))


def _join(*components):
    """ Join path properly """
    result = os.path.join(*components)

    if PLATFORM_SYSTEM == P_CYGWIN and result.startswith('/cygdrive'):
        result = result.replace('/cygdrive/c', 'C:')
        result = result.replace('/', '\\')

    return result


def _roaming_path(*components):
    """ Path in roaming folder for 'components' (relative) """
    return _join(ROAMING_ROOT, *components)


def _short_path(path):
    """ Shortened 'path' if possible (replace expanded HOME with ~) """
    return path.replace(HOME, '~')


def _get_description_from_file(fpath):
    """ Return comment found on first line in 'fpath', if available """
    res = ''
    try:
        with open(fpath) as fh:
            line = fh.readline().strip()
            if line.startswith('#'):
                res = line[1:].strip()
    except Exception:
        pass

    if not res and fpath.endswith('default.cfg'):
        res = "Default settings (applied when script ran without any arguments)"

    return res


def _delete(report, path, commit):
    """ Delete file/folder with 'path' """
    if report.errors:
        return report

    if not os.path.exists(path) and not os.path.islink(path):
        return report

    if commit:
        report.log("Deleting %s", path)
        if os.path.isfile(path) or os.path.islink(path):
            os.unlink(path)

        else:
            try:
                shutil.rmtree(path)

            except Exception as e:
                report.error("Can't delete [%s]: %s", path, e)

    else:
        report.log("Will delete %s", path)

    return report


def _symlink(report, local, roaming, commit):
    """ Create symlink local -> roaming """
    if report.errors:
        return report

    if not os.path.exists(roaming) and commit:
        return report.error("%s does not exist", roaming)

    if commit:
        report.log("Creating symlink %s -> %s", local, roaming)

        try:
            os.symlink(roaming, local)

        except Exception as e:
            report.error("Can't symlink [%s] -> [%s]: %s", local, roaming, e)

    else:
        report.log("Will create symlink %s -> %s", local, roaming)

    return report


def _copy(report, source, dest, commit):
    """ Copy file/folder 'source' -> 'dest' """
    if report.errors:
        return report

    if not os.path.exists(source):
        return report.error("%s does not exist", source)

    if commit:
        report.log("Copying %s -> %s", source, dest)
        parent = os.path.dirname(dest)

        if not os.path.isdir(parent):
            try:
                os.makedirs(parent)

            except Exception as e:
                report.error("Can't create [%s]: %s", path, e)

        if os.path.isdir(source):
            try:
                shutil.copytree(source, dest, symlinks=False)

            except Exception as e:
                report.error("Can't copy [%s] -> [%s]: %s", source, dest, e)
        else:
            try:
                shutil.copy(source, dest)

            except Exception as e:
                report.error("Can't copy [%s] -> [%s]: %s", source, dest, e)

            try:
                shutil.copystat(source, dest)  # Make sure last modification time is preserved

            except Exception as e:
                report.error("Can't copy stats [%s] -> [%s]: %s", source, dest, e)

    else:
        report.log("Will copy %s -> %s", source, dest)

    return report


class Report(object):
    """ Simple reporting """

    def __init__(self, title=''):
        self.title = title
        self.messages = []
        self.logs = 0
        self.errors = 0

    def _log(self, msg, *args):
        if args:
            msg = msg % args
        if self.title:
            msg = self.title + ': ' + msg
        self.messages.append(_short_path(msg))
        return self

    def info(self, msg, *args):
        return self._log(msg, *args)

    def log(self, msg, *args):
        self.logs += 1
        return self._log(msg, *args)

    def error(self, msg, *args):
        self.errors += 1
        return self._log(msg, *args)

    def add(self, other):
        assert other
        self.logs += other.logs
        self.errors += other.errors
        for m in other.messages:
            self.messages.append(m)

    def __str__(self):
        return '\n'.join(self.messages)


class Spec(object):
    """ File or folder roaming spec """

    def __init__(self, section, name, local_path, doc, copy_only=False):
        #: Parent section, defines which roaming subfolder this should go under
        self.section = section
        #: Name of the file or folder roamed
        self.name = name
        #: Full path to local file (outside of roaming folder)
        self.local_path = os.path.expanduser(local_path)
        # Full path to roaming file (inside roaming folder)
        self.roaming_path = _roaming_path(self.section.folder, self.name)
        #: Short explanation of what the file/folder is
        self.doc = doc or ''
        if copy_only:
            self.doc = '[Copy] %s' % self.doc

        short_local_path = _short_path(local_path)
        if short_local_path not in self.doc:
            self.doc = '%s (%s)' % (self.doc.strip(), short_local_path)

        #: Copy the file from roaming <-> local when True (instead of symlinking local -> roaming)
        self.copy_only = copy_only

    def __repr__(self):
        source = _short_path(self.local_path)
        dest = _short_path(_roaming_path(self.section.folder, self.name))
        if self.copy_only:
            return '%s <-> %s' % (dest, source)
        return '%s -> %s' % (source, dest)

    def setup(self, commit):
        """
          Link 'self.local_path' to roaming correspondent,
          if roaming correspondent does not exist, create it from the contents of 'self.local_path',
          then delete self.local_path and link it to roaming
          @param bool commit: Commit changes when true
          @return Report: Report on how setup went, what was done or would be done if 'commit' was True
        """
        report = Report(self.section.folder)
        if self.copy_only:
            report.title += '+'
            needs_copy = True
            if not os.path.exists(self.roaming_path) and os.path.exists(self.local_path):
                # First time we roam this copy_only file, seed the roaming folder with it
                needs_copy = False
                _copy(report, self.local_path, self.roaming_path, commit)
            if os.path.islink(self.local_path):
                # Local path shouldn't be a symlink, probably left-over from earlier mistaken roaming
                # Example: OSX KeyBindings used to be symlinked but not anymore (sandboxed apps can't read it when symlinked)
                needs_copy = True
                _delete(report, self.local_path, commit)
            elif os.path.islink(os.path.dirname(self.local_path)):
                # Sprecial case with previous symlinking of KeyBindings by this very script...
                # This script used to symlink ~/Library/KeyBindings -> roaming (instead of ~/Library/KeyBindings/DefaultKeyBinding.dict)
                needs_copy = True
                _delete(report, os.path.dirname(self.local_path), commit)

            if not needs_copy:
                # First copy took care of things, we don't need to continue
                return report
            if not os.path.exists(self.roaming_path):
                return report.info("Skipping %s, no local and no roaming file", self.local_path)
            if os.path.exists(self.local_path):
                time_diff = os.path.getmtime(self.roaming_path) - os.path.getmtime(self.local_path)
                if abs(time_diff) < 5:
                    report.info("OK %s <-> %s", self.roaming_path, self.local_path)
                elif time_diff > 0:
                    # Roaming copy is younger
                    _copy(report, self.roaming_path, self.local_path, commit)
                else:
                    # Local copy is younger
                    _copy(report, self.local_path, self.roaming_path, commit)
            else:
                # First roaming -> local copy
                _copy(report, self.roaming_path, self.local_path, commit)
            return report

        if os.path.islink(self.local_path):
            if os.path.realpath(self.local_path) == self.roaming_path or PLATFORM_SYSTEM in (P_CYGWIN, P_WINDOWS):
                # FIXME: Need a good implementation for os.path.realpath on Windows
                return report.info("OK %s -> %s", self.local_path, self.roaming_path)
        if not os.path.exists(self.roaming_path):
            # Initialize self.roaming_path from self.local_path
            _copy(report, self.local_path, self.roaming_path, commit)
        _delete(report, self.local_path, commit)
        _symlink(report, self.local_path, self.roaming_path, commit)
        return report

    def help(self):
        return '%-20s %s' % (self.name, self.doc)


class Section(object):
    """ Roaming section """

    def __init__(self, folder):
        """
          @param str folder: Sub folder to use for this section in ROAMING_ROOT
        """
        #: Supported platforms
        self.platforms = [P_CYGWIN, P_LINUX, P_OSX, P_WINDOWS]
        #: Folder name holding the roamed settings
        self.folder = folder
        #: Specifications to roam for this section
        self.specs = []

    def __repr__(self):
        return '%s [%s] %s specs' % (self.folder, ' '.join(self.platforms), len(self.specs))

    def has_roamable(self, name):
        """
          @param str name: Name of roamable
          @return bool: Do we have a roamable with 'name'?
        """
        if self.folder.lower() == name.lower():
            return True
        for spec in self.specs:
            if name.lower() == spec.name.lower():
                return True
        return False

    def add_spec(self, name, local_path, doc=None, copy_only=False):
        """
          @param str name: Name of the file or folder roamed
          @param str local_path: Full path to local file (outside of roaming folder)
          @param str, None doc: Short Short explanation of what the file/folder is
          @param bool copy_only: When true, copy files roaming <-> local, instead of creating a local -> roaming symlink
        """
        spec = Spec(self, name, local_path, doc, copy_only)
        self.specs.append(spec)

    def add_simple_file_spec(self, name, doc=None, local_path=None, copy_only=False):
        """
          @param str name: Name of the file or folder roamed
          @param str, None doc: Short Short explanation of what the file/folder is
          @param str local_path: Full path to local file (outside of roaming folder), default ~/.<name>
          @param bool copy_only: When true, copy files roaming <-> local, instead of creating a local -> roaming symlink
        """
        if not local_path:
            local_path = _join(HOME, '.' + name)

        local_path = os.path.expanduser(local_path)
        self.add_spec(name, local_path, doc, copy_only)

    def setup(self, settings, commit):
        """
          @param Settings settings: What the user wants roamed
          @param bool commit: Commit changes when true
          @return Report: Report on how setup went, what was done or would be done if 'commit' was True
        """
        rep = Report(self.folder)
        do_entire_section = self.folder.lower() in settings.active
        platform_supported = PLATFORM_SYSTEM in self.platforms
        match_count = 0
        for spec in self.specs:
            if not do_entire_section and not settings.is_active(spec.name):
                continue
            if spec.name in settings.exclude:
                continue
            match_count += 1
            if platform_supported:
                rep.add(spec.setup(commit))
        if match_count and not platform_supported:
            return rep.info("Skipped on this platform, only available on %s", ' '.join(self.platforms))
        return rep

    def help(self, platform):
        res = ''
        if platform and platform not in self.platforms:
            return res
        res += '%s (%s)\n' % (self.folder, self.__doc__.strip())
        for spec in self.specs:
            res += '  %s\n' % spec.help()
        return res


class ShellSection(Section):
    """ Shell specific settings """

    def __init__(self):
        super(ShellSection, self).__init__('shell')
        self.platforms = [P_CYGWIN, P_LINUX, P_OSX]
        self.add_simple_file_spec('ackrc', "ack configuration")
        self.add_simple_file_spec('agignore', "~/.agignore file")
        self.add_simple_file_spec('bash_profile', "bash login settings")
        self.add_simple_file_spec('bashrc', "bash session settings")
        self.add_simple_file_spec('bin', "~/bin folder", local_path='~/bin')
        self.add_simple_file_spec('inputrc', "Readline library configuration")
        self.add_simple_file_spec('oh-my-zsh', "oh-my-zsh checkout")
        self.add_simple_file_spec('profile', "Shell login settings")
        self.add_simple_file_spec('screenrc', "screen configuration")
        self.add_simple_file_spec('tmux.conf', "tmux configuration")
        self.add_simple_file_spec('vimrc', "VIm configuration")
        self.add_simple_file_spec('zshrc', "zsh settings")


class GitSection(Section):
    """ Shell specific settings """

    def __init__(self):
        super(GitSection, self).__init__('git')
        self.platforms = [P_CYGWIN, P_LINUX, P_OSX]
        self.add_simple_file_spec('gitconfig', "~/.gitconfig file")
        self.add_simple_file_spec('gitignore_global',
                                  "~/.gitignore_global file (if you like to have a global git ignore)")


class SshSection(Section):
    """ ssh settings """

    def __init__(self):
        super(SshSection, self).__init__('ssh')
        self.platforms = [P_LINUX, P_OSX]
        self.add_ssh_file('config', "ssh configuration (~/.ssh/config)")

    def add_ssh_file(self, name, doc=None, copy_only=False):
        self.add_spec(name, _join(HOME, '.ssh', name), doc, copy_only)


class OSXSection(Section):
    """ OSX specific settings """

    def __init__(self):
        super(OSXSection, self).__init__('osx')
        self.platforms = [P_OSX]
        self.add_spec('DefaultKeyBinding.dict', '~/Library/KeyBindings/DefaultKeyBinding.dict', copy_only=True)
        self.add_spec('com.googlecode.iterm2.plist', '~/Library/Preferences/com.googlecode.iterm2.plist',
                      'iTerm2 settings', copy_only=True)


class SublimeSection(Section):
    """ Sublime Text section (common implementation) """

    def __init__(self, version):
        self.version = version
        self.short_name = 'ST%s' % self.version
        self.long_name = 'Sublime Text %s' % self.version
        self.local_path = None
        if PLATFORM_SYSTEM == P_LINUX:
            self.local_path = _join(HOME, '.config', 'sublime-text-%s' % self.version)
        elif PLATFORM_SYSTEM == P_OSX:
            self.local_path = _join(HOME, 'Library', 'Application Support', self.long_name)
        elif PLATFORM_SYSTEM in (P_CYGWIN, P_WINDOWS):
            self.local_path = "%s\\%s" % (APPDATA, self.long_name)
        super(SublimeSection, self).__init__(self.short_name)

    def setup(self, settings, commit):
        """
          @param Settings settings: What the user wants roamed
          @param bool commit: Commit changes when true
          @return Report: Report on how setup went, what was done or would be done if 'commit' was True
        """
        rep = Report(self.short_name)
        if not settings.is_active(self.short_name):
            return rep
        if not self.local_path:
            return rep.error("Can't determine where %s settings live on this platform" % self.short_name)
        if not os.path.isdir(self.local_path):
            rep.error("%s not found in %s", self.short_name, self.local_path)
            return rep.error("Please install %s and run it at least once, then try this script again", self.short_name)
        for spec in self.specs:
            rep.add(spec.setup(commit))
        return rep

    def add_settings_folder(self, name):
        self.add_spec(name, _join(self.local_path, name), _short_path(_join(self.local_path, name)))


class Sublime3Section(SublimeSection):
    """ Sublime Text 3 settings """

    def __init__(self):
        super(Sublime3Section, self).__init__('3')
        self.add_settings_folder('Packages/User')


class RoamingRunner(object):
    def __init__(self):
        self.sections = []
        self.sections.append(ShellSection())
        self.sections.append(GitSection())
        self.sections.append(Sublime3Section())
        self.sections.append(SshSection())
        self.sections.append(OSXSection())

    def __repr__(self):
        return '%s sections' % len(self.sections)

    def all_settings(self):
        """
        @return Settings: Settings to roam everything we have
        """
        settings = Settings('all')
        for section in self.sections:
            settings.add_active(section.folder)
        return settings

    def setup(self, settings, commit):
        """
          @param Settings settings: Settings specifying what to roam
          @param bool commit: Commit changes when true
          @return Report: Report on how setup went, what was done or would be done if 'commit' was True
        """
        report = Report()
        for section in self.sections:
            report.add(section.setup(settings, commit))
        return report

    def available_bundles(self):
        res = ''
        for fname in os.listdir(ROAMING_ROOT):
            if fname.lower().endswith('.cfg'):
                res += '  %-20s %s\n' % (fname[:-4], _get_description_from_file(_roaming_path(fname)))
        if res:
            res = 'Available .cfg bundles:\n%s' % res
        return res

    def help(self, platform=None):
        """ List of roamable things for platform (if specified) """
        res = ''
        for section in self.sections:
            sh = section.help(platform)
            if sh:
                res += sh + '\n'
        res += self.available_bundles()
        return res

    def has_roamable(self, name):
        """
          @param str name: Name of roamable
          @return bool: Do we have a roamable with 'name'?
        """
        for section in self.sections:
            if section.has_roamable(name):
                return True

    def _add_to_settings(self, settings, what):
        """
          @param Settings settings: Settings to add to
          @param str what: What to add to 'settings'
        """
        if what.startswith('-'):
            settings.add_exclude(what[1:])
            return
        if self.has_roamable(what):
            settings.add_active(what)
            return
        if what == 'all':
            s = self.all_settings()
        else:
            s = self.settings_from_file(what)
        if s:
            for name in s.active:
                settings.add_active(name)
            for name in s.exclude:
                settings.add_exclude(name)
        else:
            _abort("Nothing corresponds to '%s' and no file '%s.cfg' found, typo?", what, what)

    def settings_from_file(self, name):
        """
        @param str name: File name containing the settings
        @return Settings: Settings defined in file, if any
        """
        if not name:
            return None
        fpath = _roaming_path(name + '.cfg')
        if not os.path.exists(fpath):
            return None
        try:
            settings = Settings(name)
            with open(fpath) as fh:
                in_roam_section = False
                for line in fh.readlines():
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    if line.startswith('['):
                        in_roam_section = line == '[roam]'
                        continue
                    if not in_roam_section:
                        continue
                    self._add_to_settings(settings, line)
            return settings
        except Exception as e:
            print("Can't read file %s: %s" % (fpath, e))

        return None


class Settings(object):
    """ Settings specifying what to roam """

    def __init__(self, name):
        #: Name of setting file, if we got this object from
        self.name = name
        #: Active settings, to be roamed
        self.active = []
        #: Settings to skip
        self.exclude = set()

    def __repr__(self):
        result = '(%s) %s' % (self.name, ' '.join(self.active))
        if self.exclude:
            result = '%s [ex: %s]' % (result, ' '.join(sorted(self.exclude)))
        return result

    def is_active(self, name):
        return name.lower() in self.active

    def add_active(self, name):
        if isinstance(name, list):
            for s in name:
                self.add_active(s)
        else:
            self.active.append(name.lower())

    def add_exclude(self, name):
        if isinstance(name, list):
            for s in name:
                self.add_exclude(s)
        else:
            self.exclude.add(name)


def _abort(message, *args):
    if args:
        message = message % args
    print(message)
    print("See --help and/or --list for instructions")
    sys.exit(1)


def main():
    runner = RoamingRunner()

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-l', '--list', action='store_true', help="List what can be specified as what to roam.")
    parser.add_argument('-c', '--commit', action='store_true', help="Commit changes.")
    parser.add_argument('what', nargs='*', help="What to roam (see --list for what's available).")
    args = parser.parse_args()

    if args.list:
        print(runner.help())
        sys.exit(0)

    if args.what:
        settings = Settings('command line')
        for what in args.what:
            runner._add_to_settings(settings, what)
        if not settings.active:
            _abort("Couldn't figure out what to roam with '%s'", ' '.join(args.what))

    else:
        settings = runner.settings_from_file('default')

    if not settings:
        print("Specify which settings to roam (see --help)")
        print("You can also create a 'default.cfg' file in the roaming folder (%s)" % ROAMING_ROOT)
        print("See 'bash.cfg' for an example of how to write a 'default.cfg' file")
        sys.exit(1)

    report = runner.setup(settings, args.commit)

    if not report.messages:
        _abort("Couldn't figure out what to roam with '%s'", ' '.join(args.what))

    print(report)

    if not args.commit and report.logs and not report.errors:
        print("Use -c to effectively perform these changes")

    elif not report.logs and not report.errors:
        print("All good")


if __name__ == "__main__":
    if not HOME:
        _abort("Could not determine HOME folder, please check this script")

    main()
